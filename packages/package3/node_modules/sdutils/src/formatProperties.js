
/**
 * 格式化事件属性和用户属性工具方法
 * @param {Object} properties
 * @param {Object} userProperties 用户属性
 */
import cloneDeep from 'lodash.clonedeep';
 
export default function({properties = {}, userProperties = {}}) {
  properties = cloneDeep(properties);
  userProperties = cloneDeep(userProperties);
  const DICT = {
    'event': {
      label: '事件属性',
      prefix: 'event',
      icon: 'event-property'
    },
    'session': {
      label: "Session 属性",
      prefix: 'session',
      icon: 'session-property'
    },
    'common': {
      label: "用户属性",
      prefix: 'user',
      icon: 'user-property'
    },
    'plans': {
      label: "运营计划",
      prefix: 'user'
    },
    'user_tags': {
      label: "标签",
      prefix: 'user',
      icon: 'user-tag'
    },
    'user_groups': {
      label: "用户群",
      prefix: 'user',
      icon: 'team'
    }
  }
  // 递归格式化用户属性
  const formatUserProp = (arr = []) => {
    return arr.map(function(obj) {
      if (obj.items) {
        // items 存在为目录
        obj.properties = formatUserProp(obj.items);
        delete obj.items
      } else {
        obj.fullName = "user." + (obj.property ? obj.property.name : obj.name);
        obj.data_type = obj.property ? obj.property.data_type.toLowerCase() : obj.data_type.toLowerCase();
        if (obj.has_dict) {
          obj.data_type = 'string';
        }
      }
      if (obj.type) {
        obj.type = obj.type.toLowerCase();
      }
      return obj;
    });
  }
  let propertyList = []
  const { event = [], session = [] } = properties
  let allProperty = Object.assign({}, userProperties, {event, session})
  Object.keys(DICT).forEach(key => {
    propertyList.push({...DICT[key], name: key, properties: allProperty[key] || []})
  })
  for (let data of propertyList) {
    // 处理无目录数据
    if (data.prefix !== 'user') {
      data.properties.forEach(item => item.fullName = `${data.prefix}.${item.event_name}.${item.name}`)
    } else {
      data.properties = formatUserProp(data.properties)
    }
  }
  return propertyList
}
